# Workstream 1: Daily Loop Trust Fixes

**Author:** Tom (via Claude strategic session)
**Date:** February 9, 2026
**Purpose:** Implementation spec for Claude Code. Fixes three friction points discovered during Week 5 self-use that undermine trust in the daily experience.

---

## Context

During self-use testing (Phase 2 of the Q1 build plan), three recurring friction points emerged that collectively erode the daily loop experience. The initial conversational intake builds a coaching relationship — but the daily loop feels like it doesn't remember you, can't figure out what day it is, and might lose your data at any moment.

These aren't feature gaps. They're trust failures. Until these are fixed, we can't honestly evaluate whether the daily loop is engaging enough to sustain use — which is the Week 6 gate question.

### The three problems

**1. Date handling is broken (UTC vs. local time)**

Every date calculation in the app uses `new Date().toISOString().split('T')[0]`, which returns the UTC calendar date, not the user's local date. For a user in JST (UTC+9), this accidentally works most of the time — but checking in after midnight for a 9pm habit produces the wrong date. For users in US timezones (negative UTC offsets), checking in at 11pm local can produce *tomorrow's* UTC date. This silently corrupts the check-in history, calendar display, and state machine routing.

Additionally, there's no mechanism to log for a previous day. A 9pm habit naturally gets logged the next morning — but `logCheckIn()` always stamps "today," leaving yesterday blank and creating a phantom miss.

**2. localStorage has no safety net**

There's zero backup, versioning, or export. `loadHabitData()` silently returns `createInitialHabitData()` on any parse failure. If Safari's storage pressure, a browser clear, or any corruption event hits, the user loses everything with no warning and no recovery path.

**3. AI conversations have no memory across days**

Each daily reflection, recovery coach, and weekly reflection conversation starts from scratch. The AI receives today's check-in, pattern summaries, and intake context (goal + blocker) — but never sees what the user said in previous conversations. If the user told Tuesday's coach "my partner stays up late and it makes this hard," Wednesday's coach has no idea. The rich qualitative data users share gets compressed to a `missReason` string and a `reflection.summary`, losing all texture.

This is the primary source of the "the AI doesn't remember what I told it" feeling, which directly undermines the product's core promise of a coaching relationship that builds over time.

---

## Scope of Fixes

Three tiers, ordered by dependency and impact. Complete Tier 1 before starting Tier 2, etc.

---

### Tier 1: Fix What's Broken (trust-critical)

These are bugs and missing safety nets that actively corrupt the user experience.

#### 1A. Local date handling utility

**What:** Replace all UTC date logic with a single utility function that returns the user's local calendar date.

**Why:** Every date-dependent function (check-in stamping, `didCompleteToday()`, `didMissYesterday()`, calendar display) currently uses `new Date().toISOString().split('T')[0]` which returns UTC, not local time.

**Implementation:**

Create a new utility file `src/lib/dateUtils.ts`:

```typescript
/**
 * Returns the local calendar date as YYYY-MM-DD.
 * This is THE date function used everywhere in the app.
 * Never use new Date().toISOString().split('T')[0] — that's UTC.
 */
export function getLocalDateString(date: Date = new Date()): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Returns yesterday's local calendar date as YYYY-MM-DD.
 */
export function getYesterdayDateString(): string {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  return getLocalDateString(yesterday);
}

/**
 * Determines if a given date string is "today" in local time.
 */
export function isToday(dateStr: string): boolean {
  return dateStr === getLocalDateString();
}

/**
 * Determines if a given date string is "yesterday" in local time.
 */
export function isYesterday(dateStr: string): boolean {
  return dateStr === getYesterdayDateString();
}
```

Then find and replace every instance of `new Date().toISOString().split('T')[0]` across the codebase with the appropriate utility. Key locations:
- `habitStore.ts` — `logCheckIn()`, `updateTodayCheckIn()`, `updateTodayConversation()`
- `useUserState.ts` — `didCompleteToday()`, `didMissYesterday()`
- `CheckInFlow.tsx` — `finalizeCheckIn()`
- Any component that renders dates or compares date strings

**Acceptance criteria:**
- No instance of `toISOString().split('T')[0]` remains anywhere in the codebase
- A check-in logged at 11:30pm JST on Feb 9 is stamped as `2026-02-09`
- A check-in logged at 12:30am JST on Feb 10 is stamped as `2026-02-10`
- `didMissYesterday()` correctly evaluates based on local dates
- Calendar display matches local dates

#### 1B. "Log for yesterday" backfill flow

**What:** When the user opens the app and yesterday has no check-in, offer a disambiguation before routing to recovery.

**Why:** For evening habits (like a 9pm wind-down), the natural logging moment is the next morning. Currently, opening the app the next morning either (a) routes to recovery for a miss that didn't happen, or (b) stamps a check-in on the wrong day.

**Implementation:**

Modify `getUserState()` in `useUserState.ts`. When the state would return `missed_yesterday`, check if the habit's anchor time suggests an evening habit (or simply always offer the choice). Instead of auto-redirecting to `/recovery`, show a disambiguation on the home screen:

```
"How did last night go?"

[✓ I did it]  →  logs check-in for YESTERDAY's date, routes to success
[✗ I missed it]  →  routes to /recovery (existing flow)  
[Skip — log for today]  →  routes to normal /today check-in
```

This requires `logCheckIn()` to accept an optional `dateOverride` parameter:

```typescript
export function logCheckIn(
  checkInData: Omit<CheckIn, 'id' | 'checkedInAt'>,
  dateOverride?: string  // YYYY-MM-DD, defaults to getLocalDateString()
): HabitData {
  const date = dateOverride || getLocalDateString();
  // ... rest of existing logic, using `date` instead of `today`
}
```

UI placement: This disambiguation should appear as a card/sheet on the PlanScreen when `getUserState()` would have returned `missed_yesterday`, replacing the aggressive auto-redirect to `/recovery`. The user stays on the home screen and makes a choice.

**Acceptance criteria:**
- If yesterday has no check-in and I open the app at 8am, I see the disambiguation — NOT auto-redirect to /recovery
- Tapping "I did it" creates a check-in with yesterday's date
- Tapping "I missed it" routes to existing recovery flow
- Tapping "Skip" lets me check in for today normally
- The calendar correctly shows yesterday as completed/missed based on my choice
- If yesterday already has a check-in (I logged in real-time), this disambiguation does not appear

#### 1C. Backup-on-write safety net

**What:** Before each `saveHabitData()`, write the previous state to a backup key. On load, detect silent wipes and offer restore.

**Why:** Until we migrate to Supabase, localStorage is the only persistence layer. One browser clear event destroys everything. This adds a minimal safety net.

**Implementation:**

Modify `saveHabitData()` in `habitStore.ts`:

```typescript
const PRIMARY_KEY = 'habit-stacker-data';
const BACKUP_KEY = 'habit-stacker-data-backup';
const BACKUP_TIMESTAMP_KEY = 'habit-stacker-backup-timestamp';

export function saveHabitData(data: HabitData): void {
  try {
    // Backup current state BEFORE overwriting
    const existing = localStorage.getItem(PRIMARY_KEY);
    if (existing) {
      localStorage.setItem(BACKUP_KEY, existing);
      localStorage.setItem(BACKUP_TIMESTAMP_KEY, new Date().toISOString());
    }
    localStorage.setItem(PRIMARY_KEY, JSON.stringify(data));
  } catch (e) {
    console.error('Failed to save habit data:', e);
    // If we can't write, don't silently fail — surface it
    throw new Error('Failed to save your data. Your browser storage may be full.');
  }
}
```

Modify `loadHabitData()` to detect wipes:

```typescript
export function loadHabitData(): HabitData {
  try {
    const raw = localStorage.getItem(PRIMARY_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed && parsed.system) return parsed;  // Valid data
    }
    
    // Primary is empty or invalid — check backup
    const backup = localStorage.getItem(BACKUP_KEY);
    if (backup) {
      const parsedBackup = JSON.parse(backup);
      if (parsedBackup && parsedBackup.system) {
        // Flag that we need to prompt the user
        return { ...parsedBackup, _needsRestoreConfirmation: true };
      }
    }
    
    return createInitialHabitData();
  } catch (e) {
    // Same backup check on parse failure
    // ...
    return createInitialHabitData();
  }
}
```

Add a restore prompt component that checks for `_needsRestoreConfirmation` on app load and shows:

```
"It looks like your data was reset. We have a backup from [timestamp]. Would you like to restore it?"

[Restore my data]  →  copies backup to primary, reloads
[Start fresh]  →  keeps initial state, clears backup
```

Also add a manual export function accessible from settings/reset page:

```typescript
export function exportHabitData(): string {
  const data = loadHabitData();
  return JSON.stringify(data, null, 2);
}
```

Render this as a "Download my data" button that triggers a JSON file download.

**Acceptance criteria:**
- Every `saveHabitData()` call writes the previous state to backup first
- If primary key is cleared/corrupted but backup exists, user is prompted to restore
- Restore actually works — all check-ins, system, reflections come back
- A "Download my data" button exists on the reset page and produces valid JSON
- If localStorage write fails (quota exceeded), an error is surfaced, not silently swallowed

#### 1D. Fix `didMissYesterday()` null check bug

**What:** `didMissYesterday()` returns `false` when `lastDoneDate` is null, meaning a user who designed a habit but never did a rep will never be prompted for recovery.

**Implementation:**

```typescript
function didMissYesterday(habitData: HabitData): boolean {
  const yesterdayStr = getYesterdayDateString();
  
  // If user has never done a rep, check if they've been in 'designed' state
  // for more than 1 day — they should get a gentle nudge, not recovery
  if (!habitData.lastDoneDate) {
    return false;  // Keep this — new users shouldn't hit recovery before their first rep
  }
  
  // Check if yesterday specifically has a check-in (not just date comparison)
  const hasYesterdayCheckIn = habitData.checkIns?.some(c => c.date === yesterdayStr);
  if (hasYesterdayCheckIn) return false;  // They logged yesterday, even if it was a miss
  
  // If last done is before yesterday and no check-in exists for yesterday
  return habitData.lastDoneDate < yesterdayStr;
}
```

Also: wire `needsReentry()` into `getUserState()` so that 7+ days inactive gets the welcome-back flow instead of recovery:

```typescript
// In getUserState(), BEFORE the missed_yesterday check:
if (needsReentry(habitData)) return 'needs_reentry';
```

**Acceptance criteria:**
- User with 0 reps sees `system_designed` state, not recovery
- User absent 2-3 days sees recovery prompt (via the backfill disambiguation from 1B)
- User absent 7+ days sees welcome-back flow, not recovery
- User who logged a miss yesterday (explicit miss check-in exists) does NOT see the backfill disambiguation

---

### Tier 2: Fix What Feels Broken (engagement-critical)

This is the reflection memory problem — the highest-leverage change for making the daily loop feel like a relationship.

#### 2A. Rolling context journal (DayMemory)

**What:** After each daily reflection or recovery conversation, generate a structured summary that captures what the user shared. Pass the last 5-7 summaries to every subsequent AI conversation.

**Why:** This is the fix for "the AI doesn't remember what I told it." Instead of dumping full conversation transcripts (expensive, noisy), we capture a distilled memory of each day's interaction that gives every AI agent continuity.

**Data model addition:**

Add to `src/types/habit.ts`:

```typescript
interface DayMemory {
  date: string;                    // YYYY-MM-DD
  outcome: 'completed' | 'missed' | 'recovered' | 'skipped';
  userShared: string;              // 1-2 sentence summary of what the user said (their words/feelings)
  frictionNote?: string;           // What was hard, in user's language
  winNote?: string;                // What worked, in user's language
  coachObservation: string;        // What the AI noticed or recommended
  emotionalTone?: string;          // e.g., "frustrated", "proud", "tired", "motivated"
}
```

Add to `HabitData`:

```typescript
interface HabitData {
  // ... existing fields
  dayMemories: DayMemory[];        // Rolling journal, latest appended
}
```

**Generation approach:**

At the end of each reflection or recovery conversation (when `updateTodayConversation()` is called), extract a `DayMemory` from the conversation messages. Two options:

**Option A (preferred): Client-side extraction.** After the conversation ends, make a lightweight API call that sends the conversation messages and asks the AI to return a structured `DayMemory` JSON. This is a simple structured output call — Haiku is fine, should be fast and cheap.

The extraction prompt:

```
You are summarizing a brief coaching conversation for future reference. 
Extract these fields as JSON:

- userShared: 1-2 sentences capturing the KEY thing the user expressed (feelings, context, struggles). Use their language where possible.
- frictionNote: If they mentioned something hard or a barrier, capture it here. null if none.
- winNote: If they mentioned something that worked or felt good, capture it here. null if none.  
- coachObservation: 1 sentence — what you (the coach) noticed, recommended, or acknowledged.
- emotionalTone: One word for the user's emotional state (e.g., "frustrated", "proud", "tired", "neutral").

Be specific, not generic. "Partner stays up late watching TV making wind-down hard" is good. "Had some challenges" is bad.

Conversation:
[messages]
```

**Option B (fallback): Rule-based extraction.** If we want to avoid the extra API call, extract `userShared` from the last user message, and `coachObservation` from the last AI message. Less rich but zero-latency.

Recommend Option A — the quality difference is significant, and it's a single Haiku call after a conversation that already used an API call.

**Storage:** Append to `habitData.dayMemories`. Keep all of them (they're small). No pruning needed at current scale.

**What if the user skips the reflection conversation?** Generate a minimal `DayMemory` from the check-in data alone:

```typescript
// If no conversation happened
const memory: DayMemory = {
  date: getLocalDateString(),
  outcome: checkIn.actionTaken ? 'completed' : 'missed',
  userShared: 'Logged without conversation.',
  coachObservation: `Rep #${repsCount} logged. Difficulty: ${checkIn.difficultyRating || 'not rated'}.`,
  emotionalTone: 'neutral',
};
```

**Acceptance criteria:**
- After every check-in (with or without conversation), a `DayMemory` is persisted
- `DayMemory` entries contain specific, non-generic content drawn from the actual conversation
- `habitData.dayMemories` accumulates across days and survives app reloads
- If the AI extraction call fails, fall back to rule-based extraction (Option B) — never lose the memory

#### 2B. Pass DayMemory context to all AI conversations

**What:** Modify the prompt construction for daily reflection, recovery coach, and weekly reflection to include the last 5-7 `DayMemory` entries.

**Implementation:**

Create a utility function:

```typescript
// src/lib/ai/memoryContext.ts

export function buildMemoryContext(dayMemories: DayMemory[], count: number = 7): string {
  if (!dayMemories || dayMemories.length === 0) {
    return 'No previous conversation history yet.';
  }

  const recent = dayMemories.slice(-count);
  
  const lines = recent.map(m => {
    let line = `- ${m.date} (${m.outcome}): ${m.userShared}`;
    if (m.frictionNote) line += ` Friction: ${m.frictionNote}.`;
    if (m.winNote) line += ` Win: ${m.winNote}.`;
    line += ` You noted: ${m.coachObservation}`;
    if (m.emotionalTone && m.emotionalTone !== 'neutral') line += ` [tone: ${m.emotionalTone}]`;
    return line;
  });

  return lines.join('\n');
}
```

Add to each prompt builder:

```
## What you and the user have discussed recently
${buildMemoryContext(habitData.dayMemories)}

IMPORTANT: Reference these previous conversations naturally. If the user mentioned a specific 
barrier or win before, follow up on it. Don't ask questions you've already explored. 
Build on the relationship — this person has been sharing with you for days/weeks.
```

Add this section to:
- `buildReflectionUserPrompt()` — daily reflection
- `buildRecoveryCoachUserPrompt()` — recovery coach  
- `buildWeeklyReflectionOpenerPrompt()` — weekly reflection

**Prompt guidance to add to each agent's system prompt:**

```
You have context from previous conversations with this user. Use it naturally:
- Reference specific things they've shared before ("Last time you mentioned X...")
- Don't re-ask questions they've already answered
- Notice patterns in their emotional state across days
- If they mentioned a barrier before and seem to have overcome it, acknowledge growth
- If the same friction keeps appearing, name it directly

Never say "based on our previous conversations" or "according to my notes" — 
just naturally incorporate what you know, like a coach who remembers their client.
```

**Acceptance criteria:**
- Daily reflection prompt includes the last 5-7 DayMemory entries
- Recovery coach prompt includes the last 5-7 DayMemory entries
- Weekly reflection prompt includes the last 7 DayMemory entries (or all if fewer)
- If user mentioned "partner stays up late" on Tuesday, Wednesday's reflection can reference it naturally
- If user had a win on Monday, the next conversation acknowledges it without being prompted
- Conversations feel like they build on each other, not reset each day

---

### Tier 3: Edge Case Quality-of-Life (do after Tier 1+2)

These are real issues that should be fixed but won't block the self-use evaluation.

#### 3A. Recovery escape hatch

**What:** Add a "Skip to today's check-in" option on the recovery screen.

**Why:** Product Law 2 says "miss is first-class" — but that means recovery should be *offered*, not *forced*. If a miss was 2-3 days ago and the user just wants to get back to their routine, forcing them through a full recovery conversation creates friction that discourages opening the app.

**Implementation:** On the recovery page (or the backfill disambiguation from 1B), add a tertiary action: "Skip recovery — go to today's check-in." This should set `state` back to `active` and clear `missedDate` without logging a recovery.

**Acceptance criteria:**
- Recovery screen has a visible (but not dominant) way to skip
- Skipping does not lose the miss data — it's still recorded
- After skipping, the user lands on the normal daily check-in
- The skip option is NOT the primary CTA — recovery should still be the encouraged path

#### 3B. Guard against multi-day miss confusion

**What:** If the user has been away 2-6 days (not long enough for reentry, but more than "missed yesterday"), adjust the recovery prompt to acknowledge the gap.

**Implementation:** Pass `daysSinceLastCheckIn` to the recovery coach prompt. If > 1 day, adjust the opening:

```
// Instead of: "Yesterday didn't happen — that's completely normal"
// Use: "It's been a few days. Life happens. Let's just get you back on track."
```

**Acceptance criteria:**
- Recovery conversation acknowledges multi-day gaps when they occur
- Tone remains non-punitive regardless of gap length
- 7+ day gap routes to reentry (from 1D), not recovery

---

## Implementation Order

```
Week 1:
  Day 1-2:  1A (date utility) + 1D (didMissYesterday fix + reentry wiring)
  Day 3:    1B (backfill flow — depends on 1A for correct date handling)
  Day 4:    1C (backup-on-write)
  Day 5:    2A (DayMemory data model + generation)

Week 2:
  Day 1-2:  2B (pass memory context to all AI prompts)
  Day 3:    3A + 3B (recovery escape hatch + multi-day awareness)
  Day 4-5:  Testing, friction capture, iterate
```

**Total estimated effort:** ~8-10 days of Claude Code work sessions.

---

## What's Explicitly Out of Scope

- Supabase migration (that's Workstream 2)
- New features (multi-habit, graduation, new AI roles)
- Navigation restructuring
- Responsive design improvements
- Onboarding flow changes
- Photo journal improvements
- Any feature not directly related to daily loop trust

The goal is to make the existing daily loop trustworthy and continuous-feeling. Nothing more. After these fixes, Tom runs another 7-day self-use sprint to re-evaluate the Week 6 gate question.